<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Procesos de Software</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./_assets/slides/css/filminas.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="^---" data-separator-vertical="^\r?\n----\r?\n$">
          <textarea data-template>
            

#### Ingenier√≠a de Software
# Procesos de Software
Created by <i class="fab fa-telegram"></i>
[edme88]("https://t.me/edme88")

---
<!-- .slide: style="font-size: 0.60em" -->
<style>
.grid-item {
    border: 3px solid rgba(121, 177, 217, 0.8);
    padding: 20px;
    text-align: left !important;
}

.exercise-slide {
  border: 2px dashed #b58900;
  border-radius: 12px;
  padding: 20px;
}
</style>
## Temario
<div class="grid-item">

### Procesos de Software
* Definici√≥n
* Descripciones
* Plan y Procesos
* Modelos
  * Modelo de Cascada
  * Desarrollo Incremental
  * Orientado a Reutilizaci√≥n
* Componentes de Software
* Actividades de Proceso
* Especificaciones de Software
</div>

---
### El proceso del Software
<!-- .slide: style="font-size: 0.80em" -->
* Un conjunto estructurado de actividades necesarias para desarrollar un sistema de software
* Muchos de los procesos de software son diferentes, pero todos implican:
  * **Especificaci√≥n** - la definici√≥n de lo que el sistema debe hacer;
  * **Dise√±o e implementaci√≥n** - la definici√≥n de la organizaci√≥n del sistema y la implementaci√≥n del sistema;
  * **Validaci√≥n** - la comprobaci√≥n de que hace lo que quiere el cliente;
  * **Evoluci√≥n** - el cambio del sistema en respuesta a las necesidades cambiantes de los clientes.
* Un modelo de proceso de software es una representaci√≥n abstracta de un proceso. Se presenta una descripci√≥n de un 
proceso a partir de una perspectiva particular.

---
### Descripciones de procesos de software
<!-- .slide: style="font-size: 0.80em" -->
* Cuando describimos y discutimos los procesos, por lo general hablamos de las **actividades** en estos procesos, como la 
especificaci√≥n de un modelo de datos, el dise√±o de una interfaz de usuario, etc, y el ordenamiento de estas actividades.
* Descripciones de proceso tambi√©n pueden incluir:
  * **Productos**, que son los resultados de una actividad del proceso;
  * **Roles**, que reflejan las responsabilidades de las personas involucradas en el proceso;
  * **Pre-y post-condiciones**, que son declaraciones que son verdaderas antes y despu√©s de una actividad de proceso se ha 
promulgado o elaborado un producto.

---
### Proceso dirigido por Plan y procesos √°giles
<!-- .slide: style="font-size: 0.90em" -->
* En un desarrollo **dirigido por plan** todas las actividades del proceso se planifican con antelaci√≥n y el progreso se 
mide en contra de este plan.
* En los procesos **√°giles**, la planificaci√≥n es gradual y es m√°s f√°cil para cambiar el proceso para reflejar los requisitos cambiantes de los clientes.
* En la pr√°ctica, la mayor√≠a de los procesos pr√°cticos incluyen elementos de ambos enfoques el dirigido por plan y el √°gil.
* No hay procesos de software correctos o incorrectos.

---
### Modelos de procesos de software
<!-- .slide: style="font-size: 0.80em" -->
* **El modelo de cascada** <br>
Modelo dirigido por  Plan. Fases separadas y distintas de especificaci√≥n y desarrollo.

* **El desarrollo incremental** <br>
Especificaci√≥n, desarrollo y validaci√≥n se intercalan. Puede ser el dirigido por plan o √°gil.

* **Ingenier√≠a de software orientado a reutilizaci√≥n** <br>
El sistema se ensambla a partir de componentes existentes. Puede ser el dirigido por plan o √°gil.

**En la pr√°ctica, la mayor√≠a de los grandes sistemas se desarrollan mediante un proceso que incorpora elementos de todos estos modelos.**

---

### Metodolog√≠as de Desarrollo de Software

![Metodolog√≠as de Desarrollo de Software](images/unidad2/metodologias.png)

---
### Modelo de Cascada
![Modelo Cascada](images/unidad2/modelo-cascada.jpg)

----

### Fases del Modelo de Cascada
<!-- .slide: style="font-size: 0.90em" -->
Hay fases identificadas por separado en el modelo de cascada:
1. El an√°lisis de requerimientos y su definici√≥n
2. El dise√±o del sistema y del software
3. Implementaci√≥n y prueba  de unidades
4. Integraci√≥n y pruebas del sistema
5. Operaci√≥n y mantenimiento

El principal inconveniente del modelo de la cascada es la dificultad de acomodar el cambio despu√©s de que est√° en marcha 
el proceso. En principio, **una fase tiene que ser completa antes de pasar a la siguiente fase**.

----

### Problemas del Modelo de Cascada
<!-- .slide: style="font-size: 0.90em" -->
* **Inflexible**, la divisi√≥n del proyecto en fases estructuradas hace dif√≠cil responder a las necesidades cambiantes de 
los clientes. Por lo tanto, este modelo s√≥lo es apropiado cuando los *requisitos son bien entendidos* y los cambios ser√°n 
bastante limitados durante el proceso de dise√±o.
* POCOS SISTEMAS tienen requisitos estables.
* El modelo de cascada se utiliza sobre todo para los grandes proyectos de ingenier√≠a de sistemas especialmente si un 
sistema se desarrolla en varios lugares. En estas circunstancias el modelo de cascada ayuda a coordinar el trabajo.

----

### Ejercicio

<img src="images/question.png" style="float: right">

Piense que proyectos podr√≠an desarrollarse empleando el **modelo de cascada**.

----

### Ejercicio

<!-- .slide: style="font-size: 0.80em" -->
Dise√±ar una aplicaci√≥n simple (ej: una calculadora, gestor de tareas o agenda de contactos) siguiendo todas las fases del modelo Waterfall.

Fases:
1. **Requerimientos:** Levantar requisitos funcionales y no funcionales.
2. **Dise√±o:** Hacer diagramas de arquitectura, clases o flujo.
3. **Implementaci√≥n:** Programar el sistema seg√∫n el dise√±o.
4. **Pruebas:** Crear y ejecutar pruebas unitarias y de integraci√≥n.
5. **Despliegue simulado:** Documentar c√≥mo se har√≠a el despliegue.
6. **Mantenimiento (opcional):** Proponer c√≥mo se manejar√≠an cambios.

üîÅ Reflexi√≥n final: Analizar qu√© pas√≥ si un error apareci√≥ en implementaci√≥n, ¬øa qu√© fase hubiera sido necesario volver?

---
### Desarrollo incremental
Especificaci√≥n, desarrollo y validaci√≥n se intercalan.

Se aplica este tipo de modelo cuando los requerimientos est√°n razonablemente claros desde el principio.

----

### El desarrollo incremental
![Desarrollo Incremental](images/unidad2/desarrollo-incremental.jpg)

----

### El desarrollo incremental

![Desarrollo Incremental](images/unidad2/desarrollo-incremental2.png)

----

### Beneficios de desarrollo incremental
<!-- .slide: style="font-size: 0.80em" -->
* El costo de atender las necesidades cambiantes de los clientes se reduce.
* La cantidad de an√°lisis y la documentaci√≥n que tiene hacerse de nuevo es mucho menor que la que se requiere con el modelo de cascada.
* Es m√°s f√°cil obtener retroalimentaci√≥n de los clientes en el trabajo de desarrollo.
* Los clientes pueden hacer comentarios sobre el avance del desarrollo del software y probar lo que se ha implementado.
* M√°s r√°pida entrega y despliegue de software de utilidad para el cliente.
* Los clientes pueden usar y obtener valor a partir del software m√°s r√°pidamente  de lo que es posible con un proceso de cascada.

----

### Problemas de desarrollo incremental
<!-- .slide: style="font-size: 0.90em" -->
* El proceso no es visible.
Los gerentes necesitan entregas regulares para medir el progreso. No es rentable producir documentos que reflejen todas las versiones del sistema.

* Estructura del sistema tiende a degradarse a medida que se a√±aden nuevos incrementos.
Se gasta menos tiempo y dinero en la refactorizaci√≥n para mejorar el software, lo que tiende a corromper su estructura. La incorporaci√≥n de nuevos cambios se vuelve cada vez m√°s dif√≠cil y costoso.

---

### Ejercicio: ¬ø√Ågil o por plan?

Evalua los siguientes escenarios y eval√∫a si conviene emplear un modelo: √°gil, por plan, o h√≠brido?
(Justifica con 2 o + razones).


**Escenario 1: Software m√©dico**
Una empresa desarrolla un sistema que controla la dosis de insulina de una bomba autom√°tica. Debe pasar auditor√≠as de calidad, cumplir normativas sanitarias y garantizar cero errores.

----

**Escenario 2: App para una startup**
Un equipo de 4 personas lanza una nueva app para compartir recetas en comunidad. Quieren salir al mercado r√°pidamente y validar con usuarios reales antes de invertir m√°s.

**Escenario 3: Sistema bancario de backend**
Se va a reemplazar el sistema de liquidaci√≥n de sueldos y cuentas corrientes de un banco nacional. El nuevo sistema debe integrarse con los existentes y cumplir requisitos legales estrictos.

----

**Escenario 4: Plataforma educativa online**
Una universidad quiere desarrollar su propia plataforma de clases virtuales. Saben lo b√°sico que quieren, pero esperan hacer muchos ajustes seg√∫n la experiencia del alumnado y el equipo docente.

**Escenario 5: Aplicaci√≥n para automatizar invernaderos**
Una empresa agroindustrial quiere monitorear temperatura y riego con sensores en tiempo real. No hay una soluci√≥n previa, pero quieren ver resultados r√°pidos en campo.

<!--
| Escenario                             | Enfoque Recomendado | Justificaci√≥n Principal                                     |
|---------------------------------------|----------------------|--------------------------------------------------------------|
| **1. Software m√©dico**                | Por plan             | Riesgo alto, normativa estricta, necesidad de trazabilidad. |
| **2. App de recetas para startup**    | √Ågil                 | Cambios frecuentes, MVP, feedback de usuarios constante.     |
| **3. Backend bancario**               | Por plan o h√≠brido   | Integraci√≥n cr√≠tica, cumplimiento legal, alto riesgo.        |
| **4. Plataforma educativa**           | √Ågil o h√≠brido       | Requisitos adaptables, experiencia del usuario evolutiva.    |
| **5. Automatizaci√≥n de invernaderos** | √Ågil                 | Pruebas en campo, prototipado, necesidad de ajustes r√°pidos. |
-->

----

<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr style="background-color: #f2f2f2;">
      <th>Criterio</th>
      <th>√Ågil</th>
      <th>Por Plan</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Nivel de incertidumbre</td>
      <td>Alto</td>
      <td>Bajo</td>
    </tr>
    <tr>
      <td>Cambios frecuentes esperados</td>
      <td>S√≠</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Necesidad de cumplir normativas</td>
      <td>No obligatorio</td>
      <td>Cr√≠tica</td>
    </tr>
    <tr>
      <td>Tama√±o y distribuci√≥n del equipo</td>
      <td>Peque√±o, flexible</td>
      <td>Grande, estructurado</td>
    </tr>
    <tr>
      <td>Presupuesto fijo</td>
      <td>No necesariamente</td>
      <td>S√≠</td>
    </tr>
    <tr>
      <td>Riesgo del error</td>
      <td>Bajo o moderado</td>
      <td>Alto</td>
    </tr>
  </tbody>
</table>

---

### Ingenier√≠a de software orientado a Reutilizaci√≥n
<!-- .slide: style="font-size: 0.90em" -->
Se basa en la reutilizaci√≥n sistem√°tica de c√≥digo, los sistemas se integran a partir de componentes o sistemas existentes.

Etapas del proceso
1. An√°lisis de requerimientos
2. An√°lisis de los componentes
3. Modificaci√≥n de requerimientos
4. Configuraci√≥n del sistema con la reutilizaci√≥n
5. Desarrollo e integraci√≥n

La reutilizaci√≥n es ahora el enfoque est√°ndar para la construcci√≥n de muchos tipos de sistemas.

----

### Ingenier√≠a de software orientado a Reutilizaci√≥n

El modelo se basa en la reutilizaci√≥n sistem√°tica de c√≥digo, en integrar componentes o sistemas pre-existentes.

En este modelo se distinguen las siguientes etapas:
1. An√°lisis de requerimientos
2. An√°lisi de los componentes
3. Modificaci√≥n de requerimientos
4. Configuraci√≥n del sistema con la reutilizaci√≥n
5. Desarrollo e integraci√≥n

----

### Ingenier√≠a de software orientado a Reutilizaci√≥n
![Software Orientado a Reutilizaci√≥n](images/unidad2/software-reutilizacion.jpg)


---

### Ejercicio: ¬øDesarrollo propio o reutilizaci√≥n?

De cada uno de los siguientes escenario analiza:
1. ¬øQu√© reutilizar√≠as?
2. ¬øQu√© desarrollar√≠as desde cero?
3. Riesgos de reutilizar
4. Beneficios esperados

----

**Escenario 1:** Sistema de turnos para consultorios m√©dicos
Un centro m√©dico peque√±o quiere un sistema para registrar pacientes, asignar turnos y enviar recordatorios por correo electr√≥nico.

<p class="fragment"> 1. M√≥dulo de login, calendarios, env√≠o de correos </p>
<p class="fragment"> 2. Registro de pacientes con l√≥gica m√©dica propia </p>
<p class="fragment"> 3. Falta de integraci√≥n con normas de salud </p>
<p class="fragment"> 4. Menor tiempo de desarrollo </p>

----

**Escenario 2:** Plataforma de e-learning personalizada para una universidad
La universidad quiere un campus virtual a medida, con integraci√≥n con sus sistemas internos y funcionalidades como clases en vivo, foros y ex√°menes.

<p class="fragment"> 1. LMS base como Moodle </p>
<p class="fragment"> 2. Integraci√≥n con sistemas internos </p>
<p class="fragment"> 3. Limitaciones en personalizaci√≥n </p>
<p class="fragment"> 4. Ahorro de costos inicial </p>

---

### Modelo Evolutivo
<!-- .slide: style="font-size: 0.90em" -->
El modelo se construye mediante una serie de **prototipos**, que se van refinando y evolucionando con el tiempo.
Permite al cliente explorar requisitos poco claros o cambiantes. Se parte con una versi√≥n b√°sica y se mejora a partir del feedback del usuario.

En este modelo se distinguen las siguientes fases:
1. Desarrollo de un prototipo inicial
2. Retroalimentaci√≥n del usuario
3. Refinamiento del prototipo
4. Se repite el ciclo hasta llegar al producto final.

Generalmente se aplica este tipo de modelo cuando los requerimientos no est√°n bien definidos desde el principio.

----

### Modelo Evolutivo: Prototipado

![Paradigma de Prototipos(Pressman)](images/unidad2/prototipado.png)

----

### Ejercicio: Modelo Evolutivo

Supongamos que se desea desarrollar un software para la **gesti√≥n de tareas**.
Desarrollo un Sketch sencillo (pizarron), y realice preguntas a su cliente (profe),
para obtener **retroalimentaci√≥n** y **refinar** el producto.

---

### Iteraci√≥n de los procesos

Enfoque donde cada etapa o ciclo se repite para refinar y mejorar un producto o proyecto.

- **Entrega incremental:** se divide el proyecto en etapas que se van entregando gradualmente.
- **Desarrollo en espiral:** se utilizan ciclos de planificaci√≥n, dise√±o desarrollo, prueba y evaluaci√≥n para gestionar los riesgos y las complejidades del proyecto.

----

## Desarrollo Incremental y Entrega incremental NO son lo mismo

----

### Entrega incremental
<!-- .slide: style="font-size: 0.80em" -->
Enfoque en c√≥mo se **libera el producto al usuario**

*Qu√© significa:* El producto se entrega por partes (incrementos) que ya funcionan por s√≠ solas y aportan valor al usuario.

*Cu√°ndo ocurre:* Despu√©s de que un incremento est√° desarrollado, probado y listo, se libera para su uso.

*Objetivo:* Entregar valor lo antes posible y permitir retroalimentaci√≥n temprana.

Ejemplo:
- Sprint 1: se libera el m√≥dulo de registro de usuarios.
- Sprint 2: se libera la gesti√≥n de perfiles.
- Sprint 3: se libera el sistema de pagos.

Cada entrega es usable por el usuario final.

----

### Entrega Incremental
![Entrega Incremental](images/unidad2/entrega-incremental.jpg)

----

### Desarrollo incremental
<!-- .slide: style="font-size: 0.70em" -->
Enfoque en c√≥mo se **construye el producto** internamente

*Qu√© significa:* El producto se desarrolla en peque√±os incrementos funcionales, pero no necesariamente se entregan al usuario inmediatamente.

*Cu√°ndo ocurre:* Durante el proceso de construcci√≥n, cada incremento es una mejora sobre el anterior, aunque pueda ser interno o no visible para el cliente.

*Objetivo:* Dividir el trabajo en piezas manejables y reducir riesgos t√©cnicos.

Ejemplo:
- Iteraci√≥n 1: crear la base de datos y API para registrar usuarios (sin interfaz).
- Iteraci√≥n 2: a√±adir la interfaz gr√°fica del registro.
- Iteraci√≥n 3: integrar validaciones y pruebas.

Aqu√≠ quiz√°s reci√©n se entrega al usuario al final, cuando todo est√° integrado.

----

<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Aspecto</th>
      <th>Entrega incremental</th>
      <th>Desarrollo incremental</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Foco</td>
      <td>Poner funcionalidad en manos del usuario cuanto antes</td>
      <td>Construir el producto en partes peque√±as y manejables</td>
    </tr>
    <tr>
      <td>Visibilidad para el cliente</td>
      <td>Alta: cada incremento es √∫til y visible</td>
      <td>Variable: puede ser interno y no visible</td>
    </tr>
    <tr>
      <td>Momento de uso</td>
      <td>Inmediato tras la entrega</td>
      <td>Puede ser despu√©s de varias iteraciones</td>
    </tr>
    <tr>
      <td>Beneficio principal</td>
      <td>Retroalimentaci√≥n temprana y valor r√°pido</td>
      <td>Control t√©cnico y reducci√≥n de riesgos</td>
    </tr>
  </tbody>
</table>

----

### Ventajas entrega incremental
* El sistema est√° disponible antes, con cada entrega se agrega funcionalidad al sistema.
* Las primeras entregas act√∫an como un prototipo, esto es √∫til para el esclarecimiento de requisitos para incrementos posteriores.
* Menor riesgo de fracaso del proyecto en general.
* Los servicios de mayor prioridad se entregan antes y tienden a recibir la mayor cantidad de pruebas.

----

### Problemas de entrega incremental
<!-- .slide: style="font-size: 0.90em" -->
La mayor√≠a de los sistemas requieren un conjunto de servicios b√°sicos que se utilizan por diferentes partes del sistema.
Dado que los requisitos no est√°n definidos en detalle hasta que se llegue al  incremento de su ejecuci√≥n, puede ser dif√≠cil identificar las funcionalidades comunes que son necesarias para todos los incrementos.

La esencia de los procesos iterativos es que la especificaci√≥n se desarrolla en conjunto con el software.
Sin embargo, esto entra en conflicto con el modelo de adquisici√≥n de muchas organizaciones, donde la especificaci√≥n 
completa del sistema es parte del contrato de desarrollo del sistema.

---

### Desarrollo en Espiral
<!-- .slide: data-background="images/unidad2/ModeloEspiral.svg" style="color: white;font-weight: bold;" -->

Cada ciclo en espiral se divide en 4 sectores:
1. Establecimiento de objetivos
2. Valoraci√≥n y reducci√≥n del riesgo
3. Desarrollo y validaci√≥n
4. Planeaci√≥n

----

### Desarrollo en Espiral
<!-- .slide: style="font-size: 0.90em" -->
El proceso de desarrollo se organiza en ciclos o bucles que repiten las fases de planificaci√≥n, dise√±o, desarrollo, prueba y evaluaci√≥n.

Se enfoca en la identificaci√≥n y gesti√≥n de riesgos en cada ciclo, permitiendo tomar decisiones informadas y mitigar los riesgos potenciales.

Permite adaptarse a cambios y modificaciones durante el desarrollo del proyecto.

Facilita la incorporaci√≥n de nuevas funcionalidades o mejoras en cada iteraci√≥n, bas√°ndose en la experiencia y la retroalimentaci√≥n de los usuarios.


----

### Desarrollo en Espiral

![Modelo Espiral de Boehm](images/unidad2/modelo-espiral-boehm.png)

---

### üí° Ejercicio: Entrega Incremental
<!-- .slide: class="exercise-slide" -->
Supongamos que se desea desarrollar una **aplicaci√≥n de lista de compras** empleando el enfoque de
**Entrega incremental**. ¬øQu√© funcionalidades incluir√≠as en cada incremento?

* Incremento 1: 
* Incremento 2:
* Incremento 3:

<!--Ejemplo:
Incremento 1: Crear listas y agregar √≠tems.
Incremento 2: Marcar √≠tems como comprados.
Incremento 3: Compartir la lista con otros usuarios.
-->

Recuerda que en cada entrega, la funcionalidad debe ser usable y visible para el usuario final.

---

### üí° Ejercicio: Desarrollo en Espiral
<!-- .slide: class="exercise-slide" -->
Supongamos que se desea desarrollar una **aplicaci√≥n de lista de compras** empleando el enfoque de
**Desarrollo en Espiral**.

Para cada iteraci√≥n del espiral (ciclo), definir:
1. Objetivos (qu√© se quiere lograr en esa iteraci√≥n).
2. An√°lisis de riesgos (qu√© podr√≠a salir mal).
3. Desarrollo (qu√© se construir√°).
4. Evaluaci√≥n (c√≥mo se probar√° y evaluar√°).

<!--Ejemplo:
Iteraci√≥n 1: Prototipo b√°sico solo con creaci√≥n de listas ‚Üí Riesgo: interfaz poco intuitiva ‚Üí Soluci√≥n: prueba r√°pida con usuarios.
Iteraci√≥n 2: Agregar funci√≥n de marcar √≠tems ‚Üí Riesgo: p√©rdida de datos ‚Üí Soluci√≥n: implementar guardado autom√°tico.
-->

---
### Actividades de proceso

Procesos de software reales son *secuencias* intercalados de actividades t√©cnicas, de colaboraci√≥n y de gesti√≥n con el objetivo general de la **especificaci√≥n, dise√±o, implementaci√≥n y prueba** de un sistema de software.

---
### Actividades de proceso
Las cuatro actividades b√°sicas del proceso son: 
1. Especificaci√≥n de requerimientos
2. Dise√±o e implementaci√≥n
3. Validaci√≥n
4. Evoluci√≥n

Estas activudades est√°n organizadas de manera diferente seg√∫n el proceso de desarrollo. 
En el modelo de **cascada**, se organizan en **secuencia**, mientras que en el **desarrollo incremental** son **intercalados**.

---
#### Actividad 1: Especificaciones de Requerimientos
<!-- .slide: style="font-size: 0.80em" -->
El proceso de establecer qu√© servicios son necesarios y las limitaciones de funcionamiento y desarrollo del sistema.

Ingenier√≠a de Requisitos o Requerimientos:
* Estudio de factibilidad <br>
¬øEs t√©cnicamente y financieramente factible para construir el sistema?
* Requerimientos, obtenci√≥n y an√°lisis <br>
¬øQu√© requieren los diferentes actores del sistema o esperan del sistema ?
* Especificaci√≥n de Requerimientos <br>
Definici√≥n de los requisitos en detalle
* Validaci√≥n de Requerimientos <br>
Comprobaci√≥n de la validez de los requisitos

----

### El proceso de ingenier√≠a de requerimientos
![Ingenieria de Requerimientos](images/unidad2/ingenieria-requerimientos.jpg)

---
#### Actividad 2: Dise√±o e implementaci√≥n
* Proceso de conversi√≥n entre la especificaci√≥n del sistema en un sistema ejecutable.

* El dise√±o de software  <br>
Dise√±ar una estructura de software que da cuenta de la especificaci√≥n;

* Implementaci√≥n <br>
Traducir esta estructura en un programa ejecutable;

* Las actividades de dise√±o e implementaci√≥n est√°n estrechamente relacionados y pueden ser intercaladas.

----

### Modelo general del proceso de dise√±o
![Dise√±o de Software](images/unidad2/disenio-software.jpg)

----

### Actividades de Dise√±o
<!-- .slide: style="font-size: 0.90em" -->
* **Dise√±o arquitect√≥nico**, donde se identifica la estructura general del sistema, los componentes principales (a veces llamados subsistemas o m√≥dulos), sus relaciones y la forma en que se distribuyen.
* **Dise√±o de la interfaz**, donde se definen las interfaces entre los componentes del sistema.
* **Dise√±o de componentes**, donde se toma cada componente del sistema y el dise√±o de c√≥mo se va a operar.
* **Dise√±o de base de datos**, donde se dise√±a la estructura de datos del sistema y de c√≥mo √©stos han de estar representados en una base de datos.

---
### Actividad 3: Validaci√≥n del Software
**Verificaci√≥n y validaci√≥n** (V & V) est√° destinado a demostrar que un sistema cumple con su especificaci√≥n y cumple con los requisitos del cliente.

Involucra procesos de control, revisi√≥n y prueba del sistema.

Las pruebas del sistema implica ejecutar el sistema con casos de prueba que se derivan de la especificaci√≥n utilizando datos reales.

La prueba es la actividad de V & V m√°s utilizada.

----

### Etapas de la prueba
![Etapas de la prueba](images/unidad2/etapas-de-pruebas.jpg)

----

### Etapas de prueba
<!-- .slide: style="font-size: 0.90em" -->
* **Pruebas de Desarrollo o componente** <br>
Los componentes individuales se prueban de forma independiente;
Los componentes pueden ser funciones, objetos o agrupaciones coherentes de estas entidades.

* **Las pruebas del sistema** <br>
Pruebas del sistema como un todo. El ensayo de las propiedades emergentes es particularmente importante.

* **Las pruebas de aceptaci√≥n** <br>
Las pruebas realizadas por el cliente para verificar que el sistema cumple con sus necesidades.

----

### Fases de prueba en un proceso de software
![Fases de pruebas](images/unidad2/validacion-de-software.jpg)

---
#### Actividad 4: Evoluci√≥n
* El software es inherentemente flexible y puede cambiar.
* Las circunstancias cambiantes de negocios hacen que el software que soporta la empresa tambi√©n deba evolucionar y cambiar.
* Si bien se habla de desarrollo y evoluci√≥n (mantenimiento) como etapas diferentes, la diferencia es cada vez m√°s 
irrelevante, cada vez son menos los sistemas completamente nuevos.

----

### Evoluci√≥n del Sistema
![Evoluci√≥n del Sistema](images/unidad2/evolucion-de-software.jpg)

---

### üí° Ejercicio: Actividades del Proceso
<!-- .slide: class="exercise-slide" -->
<!-- .slide: style="font-size: 0.90em" -->

- Hablar con el cliente para entender sus necesidades	<!--Especificaci√≥n de requerimientos-->
- Definir la arquitectura del sistema	<!--Dise√±o e implementaci√≥n-->
- Corregir un bug reportado por un usuario despu√©s del lanzamiento	<!--Evoluci√≥n-->
- Ejecutar pruebas unitarias	<!--Validaci√≥n-->
- Escribir casos de prueba para un m√≥dulo	<!--Validaci√≥n-->
- Integrar los distintos m√≥dulos del sistema	<!--Dise√±o e implementaci√≥n-->
- Hacer un prototipo para validar una idea con el cliente	<!--Especificaci√≥n de requerimientos-->
- Desarrollar la base de datos	<!--Dise√±o e implementaci√≥n-->
- A√±adir una nueva funcionalidad solicitada por el usuario	<!--Evoluci√≥n-->
- Revisar el documento de requisitos con el cliente	<!--Especificaci√≥n de requerimientos-->
- Modificar el flujo de registro <!--Evoluci√≥n si es post-lanzamiento o Dise√±o e implementaci√≥n si es previo-->

---
### El problema del cambio
<!-- .slide: style="font-size: 0.90em" -->
* El cambio es inevitable en todos los grandes proyectos de software.
  * Cambios en el negocio conducen a requisitos nuevos y modificaciones  del sistema
  * Las nuevas tecnolog√≠as abren nuevas posibilidades de mejorar las implementaciones
  * Cambio de plataformas requieren cambios en las aplicaciones

* Los costos del cambio incluyen tanto la reelaboraci√≥n (por ejemplo, requisitos de re-analizar), como los costos de implementaci√≥n de nuevas funcionalidades

---
### La reducci√≥n de los costos de rehacer
<!-- .slide: style="font-size: 0.75em" -->
* **Evitar el Cambio**, donde el proceso de software incluye actividades que pueden anticipar posibles cambios para 
evitar repetir el trabajo.
  * Por ejemplo, un prototipo del sistema puede ser desarrollado para mostrar algunas de las caracter√≠sticas clave del sistema para los clientes.

* **Tolerancia al Cambio**, en el que el proceso est√° dise√±ado de modo que los cambios pueden afrontarse con un costo relativamente bajo.
  * Esto implica alguna forma de desarrollo incremental. Los cambios propuestos pueden implementarse en incrementos que a√∫n 
no se han desarrollado. S√≥lo un √∫nico incremento (una peque√±a parte del sistema) debe ser alterado para incorporar el cambio.

---
### Software Prototipado
Un prototipo es una versi√≥n inicial de un sistema que se utiliza para demostrar conceptos y probar opciones de dise√±o.

Un prototipo se puede utilizar en:
* El proceso de ingenier√≠a de requerimientos para ayudar con la obtenci√≥n de requisitos y validaci√≥n;
* En los procesos de dise√±o para explorar opciones y desarrollar un dise√±o de interfaz de usuario;
* En el proceso de pruebas.

----

### Beneficios del prototipado
* Mejora de la usabilidad del sistema.
* Una aproximaci√≥n m√°s exacta a las necesidades reales de los usuarios.
* Mejora de la calidad del dise√±o.
* Mejora de la capacidad de mantenimiento.
* Reduce del esfuerzo de desarrollo.

----

### El proceso de desarrollo de prototipos
![Proceso de prototipado](images/unidad2/desarrollo-de-prototipos.jpg)

----

### Desarrollo de prototipos
* Prototipo debe centrarse en las √°reas del producto que no se conocen bien
* La comprobaci√≥n de errores y recuperaci√≥n pueden no estar incluidos en el prototipo
* Centrarse en los requisitos funcionales y no en los  no funcionales tales como la fiabilidad y la seguridad

----

### Prototipos desechables
Los prototipos deben desecharse ya que no son una buena base para un sistema de producci√≥n:
* Puede ser imposible para ajustar el sistema para cumplir con los requisitos no funcionales;
* Los prototipos son normalmente indocumentados;
* La estructura del prototipo se suele degradarse a trav√©s de un cambio r√°pido;
* El prototipo probablemente no va a cumplir con los est√°ndares de calidad normal de la organizaci√≥n.

----

### Ejemplos de Prototipos

[Adobe XD](https://xd.adobe.com/view/79dd4690-1c36-4223-9d53-c4d50d2463c9-2c8e/)

[Nivel de Detalle](https://www.figma.com/proto/h5wKQ7FzejsrPIlw9MTKEx/Tienda-Claro---Desktop-%2B-Mobile?node-id=2265-1936&scaling=contain&page-id=0%3A1&starting-point-node-id=2265%3A1936)

---
### Actividades a realizar en grupo
En grupos de m√°ximo 3 personas deber√°n investigar las siguientes metodolog√≠as, generar un informe/ppt y presentar la investigaci√≥n al curso (fecha 23/08)

1. CLEANROOM SOFTWARE ENGINEERING
2. KANBAN
3. ADAPTIVE SOFTWARE DEVELOPMENT
4. CRYSTAL
5. LEAN SOFTWARE DEVELOPMENT (LSD)
6. FEATURE DRIVEN DEVELOPMENT
7. DEVOPS

---
## ¬øDudas, Preguntas, Comentarios?
![DUDAS](images/pregunta.gif)

          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./mermaid/dist/mermaid.min.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"progress":true,"slideNumber":true,"_":["slides"],"static":"public"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) {
        mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
        mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
      }
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
